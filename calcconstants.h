// Inline floating point values in the calc source have been marked up like
// P(0.0f). If DUMP_CONSTANTS is 1, then P expands to store the location and
// value of the float. The first time you bring up the debug menu (`),
// these stored values get dumped as a static array (`minacalc_constant`) in
// calcconstants.gen.h, along with some other information so the GUI can make
// sense of it.
//
// If DUMP_CONSTANTS is 0, then calcconstants.gen.h is included, and P expands
// to `minacalc_constant[__COUNTER__]`. So, inline constants can be changed at
// runtime, and the perf hit is there, but not too bad.
#define DUMP_CONSTANTS 0

#ifndef __cplusplus
extern struct {
    unsigned char *file;
    int file_id;
    int line;
    float value;
} constant_info[1024];

static u8 *filename(u8 *file)
{
    isize end = strlen(file);
    isize i = end - 1;
    while (i-- > 0) {
        if (file[i] == '/' || file[i] == '\\') {
            break;
        }
    }
    isize slash = i + 1;
    u8 *result = calloc(end - slash + 1, sizeof(u8));
    memcpy(result, file + slash, end - slash);
    assert(result[end - slash] == 0);
    return result;
}

static void dump_constant_info_to_file(void)
{
    static b32 once = false;
    if (once) {
        return;
    }
    once = true;

    u8 *gen = 0;
    isize last_constant = 0;
    for (isize i = array_length(constant_info) - 1; i >= 0; i--) {
        if (constant_info[i].file != 0) {
            last_constant = i + 1;
            break;
        }
    }

    buf_printf(gen, "// File generated by calcconstants.h\n\n");
    buf_printf(gen, "static float null_constant = 0.0f;\n");
    buf_printf(gen, "thread_local float minacalc_constant[] = {");
    for (isize i = 0; i < last_constant; i++) {
        if ((i & 7) == 0) {
            buf_printf(gen, "\n    ");
        }
        buf_printf(gen, " %a,", constant_info[i].value);
    }
    buf_printf(gen, "\n};\n\n");

    buf_printf(gen, "thread_local std::vector<std::pair<std::string, float*>> MinaCalcConstants {\n");
    u8 *mod = 0;
    int last_file = 0;
    for (isize i = 0; i < last_constant; i++) {
        if (constant_info[i].file) {
            if (last_file != constant_info[i].file_id) {
                mod = filename(constant_info[i].file);
                // leak mod
            }

            isize k = i;
            while (constant_info[i].file_id == constant_info[k].file_id && constant_info[i].line == constant_info[k].line) {
                k--;
            }
            k++;
            if (k == i) {
                buf_printf(gen, "    { \"%s(%d)\", &minacalc_constant[%zd] },\n", mod, constant_info[i].line, i);
            } else {
                isize n = i - k + 1;
                buf_printf(gen, "    { \"%s(%d, %zd)\", &minacalc_constant[%zd] },\n", mod, constant_info[i].line, n, i);
            }

            last_file = constant_info[i].file_id;
        }
    }
    buf_printf(gen, "};\n\n");

    write_file("calcconstants.gen.h", gen);
}

#if DUMP_CONSTANTS
#define DUMP_CONSTANT_INFO dump_constant_info_to_file()
#else
#define DUMP_CONSTANT_INFO
#endif

#endif // not(__cplusplus)

#ifdef __cplusplus
extern "C" struct {
    unsigned char *file;
    int file_id;
    int line;
    float value;
} constant_info[1024] = {0};

#if DUMP_CONSTANTS
static void add_constant_info(int id,  char const *file, int line, float value)
{
    assert(id < sizeof(constant_info)/sizeof(constant_info[0]));
    if (constant_info[id].file == 0) {
        int file_id = 9377747;
        for (int i = 0, len = strlen(file); i < len; i++) {
            file_id ^= file[i];
            file_id *= 1595813;
        }
        constant_info[id] = {
            (unsigned char *)file,
            file_id,
            line,
            value
        };
    }
}

#define P(value) (add_constant_info(__COUNTER__, __FILE__, __LINE__, value), (value))
thread_local std::vector<std::pair<std::string, float*>> MinaCalcConstants;
static float null_constant = 0.0f;
#else // DUMP_CONSTANTS
#include "calcconstants.gen.h"
#define P(value) minacalc_constant[__COUNTER__]
#endif

#endif // __cplusplus
